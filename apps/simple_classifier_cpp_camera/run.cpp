/*
// Copyright (c) 2018 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/

#include <iomanip>
#include <vector>
#include <memory>
#include <string>
#include <cstdlib>
#include <vector>

#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <inference_engine.hpp>

// window height and width 4:3 ratio
#define WINDOW_WIDTH 640
#define WINDOW_HEIGHT 480
#define WINDOW_NAME "simple_classifier_cpp_camera - Press any key to quit"

using namespace InferenceEngine;

#define TEXTGREEN  '\033[1;32m'
#define TEXTRED '\033[1;31m'
#define TEXTNOCOLOR '\033[0m'
#define TEXTYELLOW '\033[1;33m'

const std::string DEVICE = "MYRIAD";
std::vector<std::string> labels;
const unsigned int MAX_PATH = 256;

const int FONT = cv::FONT_HERSHEY_SIMPLEX;
const float FONT_SIZE = 0.5;
const cv::Scalar BLUE = cv::Scalar(255, 0, 0, 255);
const cv::Scalar GREEN = cv::Scalar(0, 255, 0, 255);
unsigned int SKIP_AFTER = 5;

void getNetworkLabels(std::string labelsDir, std::vector<std::string>* labelsVector)
{
    char filename[MAX_PATH];
    strncpy(filename, labelsDir.c_str(), MAX_PATH);
    FILE* cat_file = fopen(filename, "r");
    if (cat_file == nullptr) {
        std::cerr << "Could not find Category file." << std::endl;
        exit(1);
    }

    char cat_line[255];
    while (fgets(cat_line , 255 , cat_file) != NULL) {
        if (cat_line[strlen(cat_line) - 1] == '\n')
            cat_line[strlen(cat_line) - 1] = '\0';
        labelsVector->push_back(std::string(cat_line));
    }
    fclose (cat_file);
}


int main(int argc, char *argv[]) {
    try {
        if (argc != 3) {
            std::cout << "Usage : ./simple_classifier_cpp_camera <path_to_model> <path_to_labels>" << std::endl;
            return EXIT_FAILURE;
        }
        std::cout << "\n Press any key to quit.\n";
        const std::string input_model{argv[1]};
        const std::string labels_file{argv[2]};

        cv::Mat frame;
        int key;
        cv::VideoCapture capture;
        
        // Set up the camera
        capture.open(0);
        capture.set(cv::CAP_PROP_FRAME_WIDTH, WINDOW_WIDTH);
        capture.set(cv::CAP_PROP_FRAME_HEIGHT, WINDOW_HEIGHT);

        // Set up the display window
        cv::namedWindow(WINDOW_NAME, cv::WINDOW_AUTOSIZE);
        cv::resizeWindow(WINDOW_NAME, WINDOW_WIDTH, WINDOW_HEIGHT);
        cv::moveWindow(WINDOW_NAME, 0, 0);

        // Create the ie core object
        Core ie;

        // --------------------Load IR Generated by ModelOptimizer (.xml and .bin files)------------------------
        // Read the xml and bin files, set the batch size and get the network object
        CNNNetReader network_reader;
        network_reader.ReadNetwork(input_model);
        network_reader.ReadWeights(input_model.substr(0, input_model.size() - 4) + ".bin");
        network_reader.getNetwork().setBatchSize(1);
        CNNNetwork network = network_reader.getNetwork();

        // -----------------------------Prepare input blobs-----------------------------------------------------
         
        auto input_info = network.getInputsInfo().begin()->second;
        // Get the input node name
        auto input_name = network.getInputsInfo().begin()->first;

        input_info->setPrecision(Precision::U8);

        // ---------------------------Prepare output blobs------------------------------------------------------

        auto output_info = network.getOutputsInfo().begin()->second;
        // Get the output node name
        auto output_name = network.getOutputsInfo().begin()->first;

        output_info->setPrecision(Precision::FP32);

        // -------------------------Loading model to the plugin and then infer----------------------------------
        // Create executable network object by loading the network via ie core api
        auto executable_network = ie.LoadNetwork(network, DEVICE);
        // Create the inference request
        auto infer_request = executable_network.CreateInferRequestPtr();
        // Set the precision for the input
        auto input = infer_request->GetBlob(input_name);
        auto input_data = input->buffer().as<PrecisionTrait<Precision::U8>::value_type*>();
        
        // Get various input dimension values
        unsigned int channels_number = input->getTensorDesc().getDims().at(1);
        unsigned int net_input_height = input->getTensorDesc().getDims().at(2);
        unsigned int net_input_width = input->getTensorDesc().getDims().at(3);
        
        unsigned int frame_count = 0;
        // Main loop
        while (true)
        {
            // Read a frame
            capture >> frame;
            if (frame_count++ >= SKIP_AFTER) {
    	        capture >> frame;
                frame_count = 0;
            }
            // Flip the image horizontally
            cv::flip(frame, frame, 1);
            cv::Mat imgInput;
            // Image preprocessing
            cv::resize(frame, imgInput, cv::Size(net_input_height, net_input_width));
            // Buffer for input
            size_t image_size = net_input_height * net_input_width;
            // Fill the buffer with the input image data
            for (size_t pid = 0; pid < image_size; ++pid) {
                for (size_t ch = 0; ch < channels_number; ++ch) {
                    input_data[ch * image_size + pid] = imgInput.at<cv::Vec3b>(pid)[ch];
                }
            }

            /* Running the request synchronously */
            infer_request->StartAsync();
            if (OK == infer_request->Wait(IInferRequest::WaitMode::RESULT_READY)) {
                // ---------------------------Postprocess output blobs--------------------------------------------------
                // Get the inference results
                auto output = infer_request->GetBlob(output_name);
                auto output_data = output->buffer().as<PrecisionTrait<Precision::FP32>::value_type*>();
                // How many results should we display?
                unsigned int results_to_display = 1;
                
                /*  This is to sort output probabilities and put it to results vector */
                std::vector<unsigned> results;
                TopResults(results_to_display, *output, results);
                
                // Read the network labels
                getNetworkLabels(labels_file, &labels);
                
                // Get the top result
                auto result = output_data[results[0]];
                // Put together the result text that we will display
                std::string resultText = labels[results.at(0)] + " - " + std::to_string((int)(result*100)) + "%";
                // Determine the text size
                cv::Size text_size = cv::getTextSize(resultText, cv::FONT_HERSHEY_SIMPLEX, FONT_SIZE, 0, 0);
                // Draw a gray rectangle for text background
                cv::rectangle(frame, cv::Point2f(0,WINDOW_HEIGHT-20), cv::Point2f(WINDOW_WIDTH, WINDOW_HEIGHT), cv::Scalar(75,75,75), cv::FILLED);
                // Calculate the coordinate to print the text so that the text is centered
                int print_text_width = (int)((WINDOW_WIDTH - text_size.width)/2);
                // Put the text in the frame
                cv::putText(frame, resultText, cv::Point2f(print_text_width, WINDOW_HEIGHT-5), FONT, FONT_SIZE, GREEN, 1); 
            }
            // Display the image in the window
            imshow(WINDOW_NAME, frame);
            
            // If the user presses the break key exit the loop
            key = cv::waitKey(1);
            if (key != -1) {
                break;
            }
        }
        cv::destroyAllWindows();
    } catch (const std::exception & ex) {
      std::cerr << ex.what() << std::endl;
      return EXIT_FAILURE;
    }
    std::cout << "\n Finished.\n";
    return EXIT_SUCCESS;
}

